{% extends 'hw/hw.html' %}

{% block title %}CSE312: Homework 1{% endblock %}

{% block header %}
    <h1>Homework 1 - HTTP</h1>
    <hr/>
{% endblock %}

{% block task %}


    <div class="card-header section-testing">
        <div></div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>
        <h3>
            Introduction
        </h3>
        <hr/>
        <p>
            In this assignment you will build the foundation of the server that you will develop throughout the
            semester. All 4 homework assignments will continue to build on the same web app. The front end of the app
            will be provided to you, and we will release new features to the front end for each homework. You can
            clone the starter code for this assignment using the link below.
        </p>
        <p>
            GitHub Repository link: <a href=""></a>
        </p>

        <p>
            You should never need to modify this front end. The grader in Autolab wil simulate this front end code so
            any changes you make may affect the grading of your submissions (ie. Do not change the front end to fix your
            issues). Your tasks throughout the 4 homework assignments will be to build the corresponding end points
            on the back end that are called by the front end.
        </p>

        <hr/>
        <h3>
            Learning Objective
        </h3>
        <hr/>

        <p>
            This section outlines all the requirements for the learning objective portion of this assignment. You must
            complete all of these requirements. The learning objective is autograded in Autolab and you may submit as
            many times as you need to until you earn credit.
        </p>

        <p>
            This learning objective will guide you through building the foundation of a server that understands HTTP,
            communicates with a database, implements a chat feature, and utilizes cookies to track user sessions.
        </p>

        <br>
        <h4>The Request Class</h4>

        <p>
            Complete the Request class in the util package of the starter code. The constructor has been set up and
            contains
            all the instance variables that should be populated by parsing the input which will be an HTTP request in
            bytes. Your
            task is to parse the bytes and set the 'body', 'method', 'path', 'http_version', and 'headers' instance
            variables. Note that the body must be set as bytes while the other values will be set as str's (headers will
            map
            str to str).
        </p>
        <p>
            The headers variable is a dictionary that must be populated with all of the headers of the request where the
            keys in the dictionary are the names of each header and the values are the header values. You must parse all
            of
            the headers of the request and add them all to this dictionary. (Technical note: HTTP requests are allowed
            to
            contain multiple headers with the same name. This means it's not 100% correct to store headers in a
            dictionary,
            but this will serve our purposes in this course while avoiding an increase in complexity).
        </p>
        <p>
            If there is a Cookie header, all cookies must be parsed and stored in the cookies dictionary as Strings (The
            dictionary will map str to str). Your parser must support multiple cookies. Be sure to remove any
            leading/trailing white space from the cookie names and values.
        </p>
        <p>
            Note: The raw Cookies header should still be in your headers dictionary even after parsing the individual
            cookies in the cookies dictionary.
        </p>

        <h4>The Response Class</h4>

        <p>
            Complete the Request class in the util package of the starter code. Unlike the Request class, there are no
            specific instance variables that need to be set. Instead, the spec if to write specific methods (You will
            need instance variables to write these methods, but you may choose their names and they won't be accessed by
            the grader)
        </p>

        <p>In the response class, implement the following methods:</p>

        <ul>
            <li>set_status
                <ul>
                    <li>
                        Takes an int and a str
                    </li>
                    <li>
                        returns self (This will be true for most of these methods. Returning a reference to the calling
                        object
                        allows you to chain together calls)
                    </li>
                    <li>
                        Sets the status code and message for the response.
                    </li>
                    <li>
                        If this method is never called, the code and message should default to "200 OK"
                    </li>
                </ul>
            </li>

            <li>headers
                <ul>
                    <li>
                        Takes a dict of str to str
                    </li>
                    <li>
                        returns self
                    </li>
                    <li>
                        Adds all the key-value pairs from the input dict as headers to the response
                    </li>
                    <li>
                        If this method is called multiple times, all headers across all calls must be part of the
                        response
                    </li>
                </ul>
            </li>

            <li>cookies
                <ul>
                    <li>
                        Takes a dict of str to str
                    </li>
                    <li>
                        returns self
                    </li>
                    <li>
                        Adds all the key-value pairs from the input dict as cookies to the response
                    </li>
                    <li>
                        If this method is called multiple times, all cookies across all calls must be part of the
                        response
                    </li>
                </ul>
            </li>

            <li>text
                <ul>
                    <li>
                        Takes a str
                    </li>
                    <li>
                        returns self
                    </li>
                    <li>
                        Appends the input to the end of the body of the response as bytes
                    </li>
                    <li>
                        If this method is called multiple times, all text must be appended to the body. This method can
                        be combined with the bytes method (ie. calling both text and bytes should result in the text and
                        bytes from all calls appearing in the body as bytes)
                    </li>
                </ul>
            </li>

            <li>bytes
                <ul>
                    <li>
                        Takes bytes
                    </li>
                    <li>
                        returns self
                    </li>
                    <li>
                        Appends the input to the end of the body of the response
                    </li>
                    <li>
                        If this method is called multiple times, all bytes must be appended to the body. This method can
                        be combined with the text method
                    </li>
                </ul>
            </li>

            <li>json
                <ul>
                    <li>
                        Takes either a dict or a list
                    </li>
                    <li>
                        returns self
                    </li>
                    <li>
                        Set the body of the response to the input converted to json as bytes and sets the Content-Type
                        to "application/json"
                    </li>
                    <li>
                        This method can only be called once. Calling it again should replace the old body
                    </li>
                </ul>
            </li>


            <li>to_data
                <ul>
                    <li>
                        Does not take any parameters
                    </li>
                    <li>
                        returns the entire response in bytes. This is the final response that will be sent to the client
                        over the TCP socket
                    </li>
                    <li>
                        The returned bytes must be properly formatted according the HTTP protocol and must contain all
                        headers, cookies, the status code and message, and the body of the response along with the
                        Content-Length header
                    </li>
                </ul>
            </li>
        </ul>

        <h4>The Router Class</h4>

        <p>
            You'll set up a Router class that will help you organize the code of your server throughout the semester. It
            is
            recommended that you study the provided hello path from the starter code and write at least one path (eg.
            hosting the HTML file at "GET /") without using the router to gain a better understanding of the structure
            of a
            server before implementing your Router class.
        </p>
        <p>After Homework 1 you are welcome to make changes to the design of your router, but you are required to use a
            router throughout all homework assignments. The organization this router provides will prove useful as your
            server code gains more complexity.
        </p>
        <p>Write a class named Router in a file named util/router.py with the following methods and functionality:
        </p>
        <ul>
            <li>If you use a constructor, it must take no parameters</li>
            <li>A method named "add_route" that takes 4 parameters and is used to specify how to route a specific
                request based
                on its method and path
                <ul>
                    <li>The 4 parameters are
                        <ul>
                            <li>The HTTP method (str) of the request</li>
                            <li>The path (str) of the request</li>
                            <li>A function that takes a Request object, and a TCPHandler as parameters and does not
                                return anything. This will
                                be the function that handles request matching the given method and path
                            </li>
                            <li>A boolean indicating if the path must match exactly or begin with the provided path.
                                This boolean should have a
                                default value of False
                            </li>
                        </ul>
                    </li>
                    <li>The add_route method does not return anything</li>
                    <li>This method is called to add a route to the router. For example, if you have a function named
                        "send_home_page"
                        that takes a Request and a TCPHandler and send an HTTP response containing the HTML of your home
                        page using the
                        handler that should be called on a GET request for the path "/", you would call add_route("GET",
                        "/",
                        send_home_page, True)
                    </li>
                </ul>
            </li>
            <li>A method named "route_request" that takes a Request object and a TCPHandler and does not return anything
                <ul>
                    <li>
                        This method will check the method and path of the request, determine which added path should be
                        used, and call
                        the function associated with that path with arguments matching the parameters of this method
                        (eg. forward the
                        Request and TCPHandler to the matching function)
                    </li>
                    <li>If there is no path for the request, return a 404 response</li>
                    <li>If multiple routes match the request, use the route that was added first with the add_route
                        method
                    </li>
                    <li>When determining if a route is a match, the method and path must both match. If the boolean
                        (from the add_route
                        method) was True, the path must match exactly. If the boolean was False, the path of the request
                        must start with
                        the path for the route for it to be considered a match (eg. add_route("GET", "/public/image/",
                        serve_image) uses
                        the default boolean value of False so a request of "GET /public/image/eagle.jpg" would be routed
                        to the
                        serve_image function
                    </li>
                </ul>
            </li>
        </ul>


        <h4>Host Static Files</h4>

        <p>
            This is the first task where you'll start adding functionality to your server (The three classes will make
            it easier for you develop your server throughout the semester). Review the code in server.py to see how it
            uses your Router and Request classes. Then, add a route to your router that will host all files in the
            public directory.
        </p>

        <p>
            To accomplish this task, you should add a route that will match any path starting with "/public", then
            extract the file path from the rest of the path and serve that files contents in the response. For
            example, if you receive a request for the path "/public/imgs/dog.jpg", you should read the file
            "/public/imgs/dog.jpg", create a Response object, call bytes on the response and give it the contents of the
            file, call to_data to get the final response, then send the response using the handlers send_all method.
        </p>

        <p>
            All files must be served with the correct MIME type. You may use the file extensions to determine these
            MIME types.
        </p>
        <p>
            Add another path that will route "/" as an exact match and serve "public/index.html" which will load the
            homepage when someone visits your domain name. At this point, you can run your app and visit
            "http://localhost:8080" in your browser to see the provided front end.
        </p>


        <p>
            Security: The X-Content-Type-Options: nosniff header must be set on all responses (Please double/triple
            check
            this header for the exact spelling and syntax. If you are off by 1 character, the browser will not disable
            MIME
            type sniffing which renders your header useless and can be a security issue). It is recommended that
            you add this header in your Response class so you'll never forget it
        </p>

        <p>UTF-8: Some files contain emojis that will be displayed when the page loads. These characters must display
            properly.</p>

        <p>
            404: If a request is received for any path that should not serve content, return a 404 response with a
            message
            saying that the content was not found. This can be a plain text message.
        </p>


        <h4>
            Chat Feature
        </h4>

        <p>
            The front end contains a chat feature that will send specific requests to your server. To enable this
            feature, implement the following end points. Note that will need to use both a database and cookies to
            complete all of these end points. All functionality must persist through a server restart and you must
            use a MongoDB database.
        </p>


        <h5>Create Chat Message (`POST /api/chats`)</h5>

        <p>Creates a new chat message. The frontend will send a `POST` request to your backend at the route
            `/api/chats`.
            Listed below is the format expected.</p>

        <p>Request (JSON): {"content": string}</p>

        <p>Response (JSON): {"_id": string, "author": string, "content": string}</p>

        <p>Errors:</p>
        <ul>
            <li>- **400 Bad Request**: _Errors must have text in body of response, the error message is for you to
                decide
                but
                one is needed_
            </li>
        </ul>

        <p>
            If the same user creates multiple posts, all posts must have the same author. This should be tracked using a
            cookie that is set and tracked by your server.
        </p>

        <p>
            Since we don't have user accounts yet, you can choose random author names for users for now. The names must
            be different for different users
        </p>


        <h5>Get Chat Messages (`GET /api/chats`)</h5>

        <p>Retrieves all chat messages. The frontend will send a `GET` request to your backend at the route
            `/api/chats`.
            Listed below is the format expected.</p>

        <p>Response (JSON): {"messages": [{"author": string, "id": string, "content": string, "lastUpdatedAt":
            DateString}, ... ]}

        <p>The `updated` parameter that is sent back in the list of messages represents if the message has ever been
            updated. If it has it must be set to true.</p>

        <h5>Update Chat Message (`PATCH /api/chats/{id}`)</h5>

        <p>Updates an existing message with new content. The frontend will send a `PATCH` request to your backend at
            the
            route `/api/chats/{id}`. Listed below is the format expected.</p>

        <p>{"content": string}</p>

        <p>Errors:</p>
        <ul>
            <li>**400 Bad Request**: This error is for when the request is missing the content in the request body.</li>
            <li>**403 Forbidden**: This error is for when the user lacks permission (can only update own messages).</li>
            <li>**404 Not Found**: This error is for when the message with the specified ID does not exist.</li>
            <li></li>
        </ul>
        <p>Errors
            must have text in body of response, the error message is for you to decide but one is needed</p>

        <h5>Delete Chat Message (`DELETE /api/chats/{id}`)</h5>

        <p>Deletes an existing message from chat history. The frontend will send a `DELETE` request to your backend at
            the
            route `/api/chats/{id}`. Listed below is the format expected.</p>

        <p>Errors:</p>
        <ul>
            <li>**404 Not Found**: This error is for when the message with the specified ID does not exist.</li>
            <li>**403 Forbidden**: This error is for when the user lacks permission (can only delete own messages).</li>
        </ul>

        <p>Errors must have text in body of response, the error message is for you to decide but one is needed</p>


        <p>Security: You must escape any HTML in the users' messages. Since your users can submit any text they want, a
            malicious user could submit HTML tags that attack other users. You cannot allow this. You must escape any
            submitted HTML so it displays as plain text instead of being rendered by the browser.</p>


        <h4>Testing Procedure</h4>

        <ol>
            <li>This objective will be autograded in Autolab and you will receive feedback as soon as you submit. You
                are allowed as many submissions as you'd like in order to complete this objective (All application
                objectives are manually graded after the final deadline)
            </li>
        </ol>


        <hr/>
        <h3>
            Application Objective 1
        </h3>
        <hr/>

        <p>
        - add/remove reactions to chat messages (group reactions, have it be like 2 👍 1 👎)
        </p>

        <hr/>
        <h3>
            Application Objective 2
        </h3>
        <hr/>

        <p>
        - allow users to change their nickname (+ retroactively change their name in all their old messages)
        </p>

        <hr/>
        <h3>
            Application Objective 3
        </h3>
        <hr/>

        <p>
            - use [dicebear](https://www.dicebear.com/how-to-use/http-api/) for generating profile pictures and saving
        that
        to the user and saving the file
        </p>





        <h3>Submission</h3>

        <p>Submit all files for your server to Autolab in a .zip file (A .rar or .tar file is not a .zip file!)</p>


        <p>It is strongly recommended that you download and test your submission after submitting. To do this, download
        your zip file into a new directory, unzip your zip file, enter the directory where the files were unzipped,
        run
        docker compose up, then navigate to localhost:8080 in your browser. This simulates exactly what the TAs will
        do
            during grading.</p>


        <h3>Grading</h3>

        <p>Each objective will be scored on a 0-3 scale as follows:</p>

        3 (Complete)
        Clearly correct. Following the testing procedure results in all expected behavior
        2 (Complete)
        Mostly correct, but with some minor issues. Following the testing procedure does not give the exact expected
        results, but all features are functional
        1 (Incomplete)
        Not all features outlined in this document are functional, but an honest attempt was made to complete the
        objective. Following the testing procedure gives an incorrect result, or no results at all, during any step.
        This includes issues running Docker or docker-compose even if the code for the objective is correct
        0.3 (Incomplete)
        The objective would earn a 3, but a security risk was found while testing
        0.2 (Incomplete)
        The objective would earn a 2, but a security risk was found while testing
        0.1 (Incomplete)
        The objective would earn a 1, but a security risk was found while testing
        0 (Incomplete)
        No attempt to complete the objective or violation of the assignment (Ex. Using an HTTP library)


        <p>Note that for your final grade there is no difference between a 2 and 3, or a 0 and a 1. The numeric score
        is
            meant to give you more feedback on your work.</p>

        3
        Objective Complete
        2
        Objective Complete
        1
        Objective Not Complete
        0
        Objective Not Complete


        <p>Autograded objectives are graded on a pass/fail basis with grades of 3.0 or 0.0.</p>


        <h3>Security Essay</h3>
        <p>For each objective for which you earned a 0.3 or 0.2, you will still have an opportunity to earn credit for
        the
            objective by submitting an essay about the security issue you exposed. These essays must:</p>

        <ul>
            <li>Be at least 1000 words in length</li>
            <li>Explain the security issue from your submission with specific details about your code</li>
            <li>Describe how you fixed the issue in your submission with specific details about the code you changed</li>
            <li>Explain why this security issue is a concern and the damage that could be done if you exposed this issue in
        production code with live users</li>
        </ul>


        <p>Any submission that does not meet all these criteria will be rejected and your objective will remain
            incomplete.</p>

        <p>Due Date: Security essays are due 1-week after grades are released.</p>

        <p>Any essay may be subject to an interview with the course staff to verify that you understand the importance
        of
        the security issue that you exposed. If an interview is required, you will be contacted by the course staff
        for
        scheduling. Decisions of whether or not an interview is required will be made at the discretion of the
        course
            staff.</p>

        <p>When you don't have to write an essay:</p>
        <ul>
            <li>If you never submit a security violation, you never have to write an essay for this course. Be safe. Be
        secure</li>
        <li>If you earn a 0.1, there's no need to write an essay since you would not complete the objective anyway</li>
        </ul>



    </div>
{% endblock %}
