{% extends 'hw/hw.html' %}

{% block title %}CSE312: Homework 5{% endblock %}

{% block header %}
    <h1>Homework 5 - Deployment</h1>
    <hr/>
{% endblock %}

{% block task %}

    <div class="card-header section-testing">
        <div></div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>
        <h3>
            Learning Objective - HTTPS with Nginx
        </h3>
        <hr/>
        <p>
            Set up your app to listen for HTTPS requests on port 443 using a self-signed certificate and nginx
            running in a separate docker container. All features from the previous learning objectives must still be
            functional (With some reasonable exceptions. For example, it's ok if guest chat isn't working now that
            you have authenticated chat). You must include the following:
        </p>
        <ul>
            <li>
                Your server should listen for HTTP (Unencrypted) requests on port 80. Whenever a requests is received on
                port 80, you should redirect the user to the same path on port 443 using HTTPS
            </li>
            <li>
                Be sure to test your WebSocket features and make sure they use WSS. The front end will detect that
                HTTPS is being used and will attempt to establish a WSS connection
            </li>
            <li>
                Update your auth token cookie to include the "secure" directive
            </li>
        </ul>

        <p>
            When this objective is complete, you should be able to run your app using docker and navigate to
            https://localhost to use your app. Since you are now using default ports, you don't have to specify the
            port. You should also be able to visit http://localhost and see a redirect to https://localhost. When
            visiting your app for the first time, you should expect the browser to give you a warning about using
            a self-signed certificate.
        </p>
        <p>
            You will need to generate a private key and a self-signed certificate to enable HTTPS. For this objective,
            you may use an additional script to accomplish this. You should name this script "setup.sh" and save it in
            the root directory of your project. If this
            file exists, we will run it before starting your app while grading. The intent is for this script to
            generate your encryption keys, though you have the freedom to do whatever setup you'd like in this script.
            You may also choose to not include a script and set up your keys in your Dockerfile if you prefer. You
            may assume this script will be executed in a *nix environment with openssl installed.
        </p>

        <p>
            When we test your app we will:
        </p>

        <ol>
            <li>
                Run "setup.sh" if it exists
            </li>
            <li>
                Run "docker compose up"
            </li>
            <li>
                Test the features of your app at https://locahost and http://localhost
            </li>
        </ol>


        <p>
            <b>Security</b>: Do not include any private encryption keys in your submission.
        </p>

        <p>
            <b>Security</b>: Your auth token must use the secure directive.
        </p>



        <br>
        <hr>
        <h3>
            Application Objective 1 - DoS Slow Send
        </h3>
        <hr/>

        <p>
            For this objective, you will both launch a DoS slow send attack and protect against such an attack.
        </p>

        <p>
            <b>Attack</b>: In the root directory of your project, write a python script named "dos.py" that will launch
            your slow send attack. Your attack must meet the following criteria:
        </p>

        <ul>
            <li>
                It must be a slow send attack. Writing a script that successfully launches a different style of DoS
                attack will not complete this objective
            </li>
            <li>
                You may assume the target site is accepting HTTP requests on both port 80 and 8080 as well as HTTPS
                requests on port 443
            </li>
            <li>
                The attack is considered successful if the app experiences notable slow down (100's of milliseconds is
                sufficient) after running dos.py a
                single time. This slowdown should last for a significant amount (Minutes) of time while the attack
                continues. To measure the slowdown, you can check the roundtrip times of you app running without the
                attack and compare them to the times while your attack is running. The app doesn't have to completely
                shut down, but you should experience <em>at least</em> several 100 milliseconds of additional roundtrip
                time
            </li>
            <li>
                The attack will be tested on a typical CSE312 HW server that has all the features you would expect,
                including buffering, without any DoS protection
            </li>
        </ul>

        <p>
            <b>Countermeasure</b>: Protect against this attack. Any method of prevention is acceptable, though the
            intended approach is to add a timeout to your buffering code. When you detect that your app has been
            buffering for a while, close the connection. Your countermeasure must meet the following criteria:
        </p>

        <ul>
            <li>
                After a slow send attack is launched, your app recovers in a reasonable amount of time (seconds). It is
                ok to experience slowdown when the attack first begins (eg. before your timeout is reached)
            </li>
            <li>
                Your countermeasure must protect against this family of attacks, not just your implementation from this
                objective (eg. We will use our own attack during grading)
            </li>
            <li>
                All features must still work for users who are not launching a DoS attack on your server. Specifically,
                make sure your WebSocket connections do not time out
            </li>
        </ul>


        <br>
        <hr>
        <h3>
            Application Objective 2 - JWTs and Authentication Servers
        </h3>
        <hr/>

        <p>
            Create a separate authentication (auth) server that will issue JWTs when a user logs in. This auth server
            must run in a 4th container using docker compose. This server will handle all registration and login
            requests for your app. When a user connects to an endpoint of your app that requires authentication, it
            will use the self-contained JWT to verify the user. You have some freedom in your design as long as your app
            meets the following criteria:
        </p>

        <ul>
            <li>
                Use nginx to route all authentication requests (/register, /login, /logout) to your auth server, and all
                other requests to your app server
            </li>
            <li>
                The JWT's issued by your auth server must be cryptographically signed using a private key that is only
                accessible by the auth server. These must be different keys than the ones used by nginx for TLS
            </li>
            <li>
                Your app must verify JWTs without communicating with the auth server
            </li>
            <li>
                Your app must verify JWTs without a database lookup
            </li>
        </ul>

        <p>
            You will have to solve the problem of generating a public/private key pair, storing the private key only
            on the auth server, and sharing the public key with your app server. There are several ways to solve this
            problem with the intended approach being to add to your setup.sh script and handle it there. Note that you
            call a Python script from setup.sh if you prefer to do this in Python. Alternatively, you may generate these
            keys in your auth server and provide an endpoint for your app to ask the auth server for the public key.
            This is the only direct communication allowed between the two servers.
        </p>

        <p>
            You are allowed to use
            <a href="https://pyjwt.readthedocs.io/en/latest/usage.html#encoding-decoding-tokens-with-rs256-rsa">
                libraries</a> to sign and verify JWTs.
        </p>

        <p>
            <b>Security</b>: Do not include any private encryption keys in your submission.
        </p>

        <p>
            <b>Security</b>: Your JWT's must use the secure and httpOnly directives set.
        </p>

        <p>
            <b>Security</b>: Your JWT's must be cryptographically signed in a way that they cannot be forged.
        </p>

        <p>
            <b>Security</b>: Any private key(s) must only be known to you auth server. Not even your app server should
            have access to this key.
        </p>


        <br>
        <hr>
        <h3>Submission</h3>
        <hr>
        <p>Submit all files for your server to Autolab in a .zip file</p>

        <p>
            If you used any external libraries, be sure to add them to your requirements.txt. Autolab will install all
            dependencies in this file, and no other dependencies, before starting your server.
        </p>

        <div class="alert alert-info">
            It is strongly recommended that you download and test your submission after submitting. To do this, download
            your zip file into a new directory, unzip your zip file, enter the directory where the files were unzipped,
            run
            docker compose up, then navigate to localhost:8080 in your browser and test all of your features. This
            simulates exactly what the TAs will do during grading.
            <br><br>
            If you ignore this recommendation, don't be surprised when you do not earn credit for either Application
            Objective even if your code functions properly when running server.py
        </div>


        <br>
        <hr>
        <h3>Grading</h3>
        <hr>
        <p>Each objective will be scored on a 0-3 scale as follows:</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3 (Complete)</td>
                <td>Clearly correct</td>
            </tr>
            <tr>
                <td>2 (Complete)</td>
                <td>Mostly correct, but with some minor issues
                </td>
            <tr>
                <td>1 (Incomplete)</td>
                <td>Not all features outlined in this document are functional, but an honest attempt was made to
                    complete the objective
                </td>
            <tr>
                <td>0.3 (Incomplete)</td>
                <td>The objective would earn a 3, but a security risk was found while testing</td>
            <tr>
                <td>0.2 (Incomplete)</td>
                <td>The objective would earn a 2, but a security risk was found while testing</td>
            <tr>
                <td>0.1 (Incomplete)</td>
                <td>The objective would earn a 1, but a security risk was found while testing</td>
            <tr>
                <td>0 (Incomplete)</td>
                <td>No attempt to complete the objective or violation of the assignment (Ex. Using an HTTP library)</td>
        </table>
        <br>
        <p>Note that for your final grade there is no difference between a 2 and 3, or a 0 and a 1. The numeric score
            is meant to give you more feedback on your work.</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3</td>
                <td>Objective Complete</td>
            </tr>
            <tr>
                <td>2</td>
                <td>
                    Objective Complete
                </td>
            </tr>
            <tr>
                <td>1</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
            <tr>
                <td>0</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
        </table>
        <br>
        <p>Autograded objectives are graded on a pass/fail basis with grades of 3.0 or 0.0.</p>

        <br>
        <hr>
        <h3>Security Essay</h3>
        <br>
        <p>For each objective for which you earned a 0.3 or 0.2, you will still have an opportunity to earn credit for
            the
            objective by submitting an essay about the security issue you exposed. These essays must:</p>

        <ul>
            <li>Be at least 1000 words in length</li>
            <li>Explain the security issue from your submission with specific details about your code</li>
            <li>Describe how you fixed the issue in your submission with specific details about the code you changed
            </li>
            <li>Explain why this security issue is a concern and the damage that could be done if you exposed this issue
                in
                production code with live users
            </li>
        </ul>


        <p>Any submission that does not meet all these criteria will be rejected and your objective will remain
            incomplete.</p>

        <p>Due Date: Security essays are due 1-week after grades are released.</p>

        <p>Any essay may be subject to an interview with the course staff to verify that you understand the importance
            of
            the security issue that you exposed. If an interview is required, you will be contacted by the course staff
            for
            scheduling. Decisions of whether or not an interview is required will be made at the discretion of the
            course
            staff.</p>

        <p>When you don't have to write an essay:</p>
        <ul>
            <li>If you never submit a security violation, you never have to write an essay for this course. Be safe. Be
                secure
            </li>
            <li>If you earn a 0.1, there's no need to write an essay since you would not complete the objective anyway
            </li>
        </ul>


    </div>
{% endblock %}
