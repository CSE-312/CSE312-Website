{% extends 'hw/hw.html' %}

{% block title %}CSE312: Homework 1{% endblock %}

{% block header %}
    <h1>Homework 1 - HTTP</h1>
    <hr/>
{% endblock %}

{% block task %}



    <div class="card-header section-testing">
        <div></div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>
        <h3>
            Introduction
        </h3>
        <hr/>
        <p>
            You will continue to add features to your app from homework 1, though you should pull from the repo to get
            the new front end features.
        </p>
        <p>
            Sample Deployment: <a href="https://312demo.nico.engineer/">https://312demo.nico.engineer/</a>
        </p>

        <hr/>
        <h3>
            Learning Objective - Authentication
        </h3>
        <hr/>
        <p>
            In this objective, you will add all the functionality needed for authentication. By the end of this
            objective, users will be able to create and login to their account and use the chat feature from HW1
            with their chosen username as their display name.
        </p>

        <br>
        <h4>Authentication Method: extract_credentials</h4>
        <p>

            Create a file named util/auth.py containing the following functions (This file does not define a class). In
            this file,
            write a function named "extract_credentials" that takes a Request object and returns a list containing 2
            elements,
            a username then a password, both as strings (str)
        </p>
        <ul>
            <li>The request object will either be in the format of a registration or a login request as generated by the
                provided front end. You must use the front end as-is since
                this is the exact format expected by the grader in Autolab
            </li>
            <li>These requests will contain a url encoded string (The same format as query strings) containing these two
                values. You must parse the username and password from this encoded string. This includes decoding the
                percent-encoded characters
            </li>
            <li>You are not allowed to use Python's urllib, or any other library that parses url encoded strings for
                you, to write this method
            </li>
            <li>The username will only ever contain alphanumeric characters (eg. the username will never contain
                percent-encoded characters)
            </li>
            <li>The password can contain alphanumeric characters as well as the following special characters {'!', '@',
                '#', '$', '%', '^', '&', '(', ')', '-', '_', '='} (Note: We are limiting passwords to these 12 special
                characters to limit the tedium of writing this method. In the real world, you should support every valid
                character, and you would also use a library to make this support trivial)
            </li>
        </ul>

        <br>
        <h4>Authentication Method: extract_credentials</h4>
        <p>
            In util/auth.py file, write another function named "validate_password" that takes a string (str) and returns
            a boolean specifying if the password
            meets all of the following 6 criteria. If the function returns True, the password meets all the criteria and
            should be considered acceptable</p>
        <ul>
            <li>The length of the password is at least 8</li>
            <li>The password contains at least 1 lowercase letter</li>
            <li>The password contains at least 1 uppercase letter</li>
            <li>The password contains at least 1 number</li>
            <li>The password contains at least 1 of the 12 special characters listed above</li>
            <li>The password does not contain any invalid characters (eg. any character that is not an alphanumeric or
                one of
                the 12 special characters)
            </li>
        </ul>


        <br>
        <hr>
        <h4>Authenticated Chat</h4>

        <p>
            Add authentication to your app. To start, you will need to add the following paths for HTML pages that you
            will render using layout.html in the same way as index and chat from HW1.
        </p>

        <ul>
            <li>"/register" - Render register.html</li>
            <li>"/login" - Render login.html</li>
            <li>"/settings" - Render settings.html</li>
            <li>"/search-users" - Render search-users.html</li>
        </ul>


        <p>The provided register and login pages with send requests in the format expected by the extract_credentials
            function and you should use this function to extract the username and password provided by your users. Do
            not
            modify the way these forms behave.</p>

        <p>
            Your server must contain all of the following features.
        </p>

        <h6>Registration</h6>
        <p>When a user sends a registration request, store their username and a salted hash of their password in your
            database. Their password must pass the criteria tested by your validate_password method or the registration
            fails.</p>

        <p>
            If a registration is not successful (eg. password is not valid), return a 400 response with a message of
            your choosing.
        </p>

        <p><b>Security</b>: Never store plain text passwords. You must only store salted hashes of your users'
            passwords. It is
            strongly recommended that you use the bcrypt library to handle salting and hashing.</p>

        <h6>Login</h6>
        <p>When a user sends a login request, authenticate the request based on the data stored in your database. If the
            [salted hash of the] password matches what you have stored in the database, the user is authenticated.</p>


        <p>When a user successfully logs in, set an authentication token named exactly "auth_token" as a cookie for that
            user with the HttpOnly
            directive set. These token cannot be session cookies (eg. set max age or expires). You must store a hash
            (no
            salt) of each token in your database so you can verify them on subsequent requests. Remember that you do not
            hash the cookie, but you do hash what's stored in the DB</p>
        <p>
            If a login is not successful (eg. username doesn't exist), return a 400 response with a message of
            your choosing.
        </p>
        <p><b>Security</b>: Only hashes of your auth tokens should be stored in your database (Do not store the tokens
            as plain
            text). Salting is not expected.</p>
        <p><b>Security</b>: Set the HttpOnly directive on your "auth_token" cookie.</p>

        <h6>Logout</h6>
        <p>Add a path for "/logout", that is used by the logout button on the front end, that will log a user out.
            When this button is pressed, the user's auth token must be removed from their cookies and invalided
            by your server (eg. the auth token they were issued should no longer work even if your server receives it as
            a
            cookie value after log out). To remove a cookie, set a cookie with the same name and max age of 0 or an
            expires
            date in the past</p>

        <h6>Authenticated Chat</h6>
        <p>Whenever a chat message is sent by an authenticated user, the message should contain their
            actual username. This is done by setting the "author" of their messages to their username.</p>

        <p>
            When a user logs in, any messages that they sent as a guest should retroactively have their author set to
            their username. Use you "session" cookie to track messages for this purpose. You should also ensure that
            messages cannot be "claimed" multiple times (eg. If a user sends a guest message, logs in, logs out, then
            logs in using a different account the guest message should still belong to the account of their first
            login).
        </p>

        <h6>Update and Delete Messages</h6>
        <p>Modify your update and delete message functionality to be based on user accounts instead of "session"
            cookies. A user
            should be able to log out, clear their session cookie, log back in, and still be able to delete their own
            messages.</p>

        <p>When a user attempts to update or remove a message that is not their own, respond to the request with a 403
            response
            code.
            If it is their own, you may choose the response you send (200 with a short message is fine).</p>


        <h6>@me</h6>
        <p>
            Add and endpoint "/api/users/@me" that will return the requesters user profile. You should return everything in your
            database stored for the user except their [hashed and salted] password and [hashed] auth token. This is used
            to display a users name on the page when they are logged in. If the user is not logged in, this endpoint
            returns an empty json object
        </p>

        <h6>Filter/search users</h6>
        <p>
            Add an endpoint "/api/users/search" that takes a query string containing one key named "user". Return a json
            array containing all the usernames that begin with the value of "user".
        </p>

        <h6>Update profile</h6>
        <p>
            Add an endpoint to update your profile. More details to come.
        </p>


        <br>
        <hr/>
        <h3>
            Application Objective 1 - 2-Factor Authentication
        </h3>
        <hr/>

        <p>
            Add 2FA
        </p>


        <br>
        <hr/>
        <h3>
            Application Objective 2 - Login with GitHub (Oauth 2.0)
        </h3>
        <hr/>

        <p>
            Enable the "login with GitHub" button.
        </p>

        {#        Application Objective: OAuth - Login with Spotify#}
        {#        Build a login with Spotify feature. To do this, use the button labeled Login with Spotify. Then, use Spotify's#}
        {#        OAuth 2.0 API to allow your users to login using their Spotify account. After authenticating their account#}
        {#        through Spotify, use the User Profile endpoint to get the user's email address. Use this email address as their#}
        {#        username for any messages they send.#}
        {##}
        {#        You will use the Authorization Code Flow to build this feature and you should follow the documentation to guide#}
        {#        your development. You will need a Spotify account to access the dev dashboard and this can be a free account.#}
        {#        Note: You do not need to use the optional state.#}
        {##}
        {#        Use "http://localhost:8080/spotify" as your redirect_uri. The course staff will use this exact string in their#}
        {#        Spotify app used to test your app.#}
        {##}
        {#        Don't forget to add the Spotify account you'll use for testing under User Management.#}
        {##}
        {#        You may use a library (eg. requests) to send HTTP requests to the Spotify API. You are also allowed to use the#}
        {#        base64 library.#}
        {##}
        {#        Note: You are not required to handle refresh tokens for either of these AOs. You should code this for extra#}
        {#        practice and experience, but since Spotify tokens expire in 1 hour it would be too tedious to test/grade such a#}
        {#        requirement.#}
        {##}
        {#        Security: Never share your app's client secret or client id. Your submission must not contain your private#}
        {#        information and should instead have placeholder text where it should go.#}
        {##}
        {#        Instead of submitting your code with this secret and id, set these values as environment variables in your#}
        {#        docker-compose.yml file. Your submission should have placeholder values for these variables (ie. "changeMe" or#}
        {#        "Put your client secret here"). For testing, we will paste our own secret/id into your docker-compose.yml before#}
        {#        running docker compose up. You may also set your redirect_uri this way if you prefer not to hardcode it.#}
        {##}
        {#        Security: You must properly use the Authorization Code Flow. Using a different flow, or improperly using the#}
        {#        Authorization Code Flow, that exposes your app to security issues discussed in lecture is a security concern.#}
        {#        Testing Procedure#}
        {#        Create an app through Spotify's Dev Dashboard#}
        {#        Set your redirect_uri to "http://localhost:8080/spotify"#}
        {#        Under User Management, add the Spotify account you will use for testing#}
        {#        Copy your client secret and client id into the corresponding environment variables in the submissions#}
        {#        docker-compose.yml file#}
        {#        If there is an environment variable for the redirect_uri, set it to the string above. Otherwise, you may assume#}
        {#        that it is hardcoded to this string#}
        {#        Start the server using docker compose up#}
        {#        Open a browser and navigate to http://localhost:8080/#}
        {#        Click the login with Spotify button#}
        {#        When you are redirected to Spotify, accept the authorization#}
        {#        You should be redirected back to the home page#}
        {#        Send a message in chat and verify that the email used for your Spotify account is displayed as your username#}
        {#        Security: Look through the code and verify that no private information was submitted. This includes: client#}
        {#        secret, client id, access tokens, refresh tokens, or authorization codes#}
        {#        Security: Look through the code and verify that the Authorization Code Flow was properly used#}


        <br>
        <hr/>
        <h3>
            Application Objective 3 - GitHub Chat Commands
        </h3>
        <hr/>

        <p>
            Chat commands
        </p>


        <br>
        <hr>
        <h3>Submission</h3>
        <hr>
        <p>Submit all files for your server to Autolab in a .zip file</p>

        <p>
            If you used any external libraries, be sure to add them to your requirements.txt. Autolab will install all
            dependencies in this file, and no other dependencies, before starting your server.
        </p>

        <p>It is strongly recommended that you download and test your submission after submitting. To do this, download
            your zip file into a new directory, unzip your zip file, enter the directory where the files were unzipped,
            run
            docker compose up, then navigate to localhost:8080 in your browser. This simulates exactly what the TAs will
            do
            during grading.</p>

        <br>
        <hr>
        <h3>Grading</h3>
        <hr>
        <p>Each objective will be scored on a 0-3 scale as follows:</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3 (Complete)</td>
                <td>Clearly correct. Following the testing procedure results in all expected behavior</td>
            </tr>
            <tr>
                <td>2 (Complete)</td>
                <td>Mostly correct, but with some minor issues. Following the testing procedure does not give the exact
                    expected
                    results, but all features are functional
                </td>
            <tr>
                <td>1 (Incomplete)</td>
                <td>Not all features outlined in this document are functional, but an honest attempt was made to
                    complete the
                    objective. Following the testing procedure gives an incorrect result, or no results at all, during
                    any step.
                    This includes issues running Docker or docker-compose even if the code for the objective is correct
                </td>
            <tr>
                <td>0.3 (Incomplete)</td>
                <td>The objective would earn a 3, but a security risk was found while testing</td>
            <tr>
                <td>0.2 (Incomplete)</td>
                <td>The objective would earn a 2, but a security risk was found while testing</td>
            <tr>
                <td>0.1 (Incomplete)</td>
                <td>The objective would earn a 1, but a security risk was found while testing</td>
            <tr>
                <td>0 (Incomplete)</td>
                <td>No attempt to complete the objective or violation of the assignment (Ex. Using an HTTP library)</td>
        </table>
        <br>
        <p>Note that for your final grade there is no difference between a 2 and 3, or a 0 and a 1. The numeric score
            is meant to give you more feedback on your work.</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3</td>
                <td>Objective Complete</td>
            </tr>
            <tr>
                <td>2</td>
                <td>
                    Objective Complete
                </td>
            </tr>
            <tr>
                <td>1</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
            <tr>
                <td>0</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
        </table>
        <br>
        <p>Autograded objectives are graded on a pass/fail basis with grades of 3.0 or 0.0.</p>

        <br>
        <hr>
        <h3>Security Essay</h3>
        <br>
        <p>For each objective for which you earned a 0.3 or 0.2, you will still have an opportunity to earn credit for
            the
            objective by submitting an essay about the security issue you exposed. These essays must:</p>

        <ul>
            <li>Be at least 1000 words in length</li>
            <li>Explain the security issue from your submission with specific details about your code</li>
            <li>Describe how you fixed the issue in your submission with specific details about the code you changed
            </li>
            <li>Explain why this security issue is a concern and the damage that could be done if you exposed this issue
                in
                production code with live users
            </li>
        </ul>


        <p>Any submission that does not meet all these criteria will be rejected and your objective will remain
            incomplete.</p>

        <p>Due Date: Security essays are due 1-week after grades are released.</p>

        <p>Any essay may be subject to an interview with the course staff to verify that you understand the importance
            of
            the security issue that you exposed. If an interview is required, you will be contacted by the course staff
            for
            scheduling. Decisions of whether or not an interview is required will be made at the discretion of the
            course
            staff.</p>

        <p>When you don't have to write an essay:</p>
        <ul>
            <li>If you never submit a security violation, you never have to write an essay for this course. Be safe. Be
                secure
            </li>
            <li>If you earn a 0.1, there's no need to write an essay since you would not complete the objective anyway
            </li>
        </ul>


    </div>
{% endblock %}
