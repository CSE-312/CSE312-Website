{% extends 'hw/hw.html' %}

{% block title %}CSE312: Homework 2{% endblock %}

{% block header %}
    <h1>Homework 2 - Authentication</h1>
    <hr/>
{% endblock %}

{% block task %}



    <div class="card-header section-testing">
        <div></div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>
        <h3>
            Introduction
        </h3>
        <hr/>
        <p>
            You will continue to add features to your app from homework 1.
        </p>
        <p>
            Sample Deployment: <a href="https://312demo.nico.engineer/">https://312demo.nico.engineer/</a>
        </p>

        <hr/>
        <h3>
            Learning Objective - Authentication
        </h3>
        <hr/>
        <p>
            In this objective, you will add all the functionality needed for authentication. By the end of this
            objective, users will be able to create and login to their account and use the chat feature from HW1
            with their chosen username as their display name.
        </p>

        <br>
        <h4>Authentication Method: extract_credentials</h4>
        <p>

            Create a file named util/auth.py containing the following functions (Note that these functions are not
            methods of a class). In this file,
            write a function named "extract_credentials" that takes a Request object and returns a list containing 2
            elements,
            a username then a password, both as strings (str)
        </p>
        <ul>
            <li>The request object will either be in the format of a registration or a login request as generated by the
                provided front end. You must use the front end as-is since
                this is the exact format expected by the grader in Autolab
            </li>
            <li>These requests will contain a url encoded string (The same format as query strings) containing these two
                values. You must parse the username and password from this encoded string. This includes decoding the
                percent-encoded characters
            </li>
            <li>You are not allowed to use Python's urllib, or any other library that parses url encoded strings for
                you, to write this method
            </li>
            <li>The username will only ever contain alphanumeric characters (eg. the username will never contain
                percent-encoded characters)
            </li>
            <li>The password can contain alphanumeric characters as well as the following special characters {'!', '@',
                '#', '$', '%', '^', '&', '(', ')', '-', '_', '='} (Note: We are limiting passwords to these special
                characters to limit the tedium of writing this method. In the real world, you should support every valid
                character, and you would also use a library to make this support trivial. Ensure you consider/test edge
                cases when parsing)
            </li>
        </ul>

        <br>
        <h4>Authentication Method: validate_password</h4>
        <p>
            In util/auth.py file, write another function named "validate_password" that takes a string (str) and returns
            a boolean specifying if the password
            meets all of the following 6 criteria. If the function returns True, the password meets all the criteria and
            should be considered acceptable</p>
        <ul>
            <li>The length of the password is at least 8</li>
            <li>The password contains at least 1 lowercase letter</li>
            <li>The password contains at least 1 uppercase letter</li>
            <li>The password contains at least 1 number</li>
            <li>The password contains at least 1 of the special characters listed above</li>
            <li>The password does not contain any invalid characters (eg. any character that is not an alphanumeric or
                one of
                the 12 special characters)
            </li>
        </ul>


        <br>
        <hr>
        <h4>Authenticated Chat</h4>

        <p>
            Add authentication to your app. To start, you will need to add the following paths for HTML pages that you
            will render using layout.html in the same way as index and chat from HW1.
        </p>

        <ul>
            <li>"/register" - Render register.html</li>
            <li>"/login" - Render login.html</li>
            <li>"/settings" - Render settings.html</li>
            <li>"/search-users" - Render search-users.html</li>
        </ul>


        <p>The provided register and login pages with send requests in the format expected by the extract_credentials
            function and you should use this function to extract the username and password provided by your users. Do
            not
            modify the way these forms behave.</p>

        <p>
            Your server must contain all of the following features.
        </p>

        <br>
        <h5>Registration</h5>
        <p>When a user sends a registration request, store their username and a salted hash of their password in your
            database. Their password must pass the criteria tested by your validate_password method or the registration
            fails.</p>

        <p>
            If a registration is not successful (eg. password is not valid), return a 400 response with a message of
            your choosing.
        </p>

        <p>
            If registration is successful, respond with a 200 OK and any message of your choosing (The front end will
            redirect to the login page and your message won't be displayed to the user).
        </p>
        <p>
            When a user registers, you should also generate a unique id for them in the same way that chat messages have
            unique ids.
        </p>

        <p><b>Security</b>: Never store plain text passwords. You must only store salted hashes of your users'
            passwords. It is
            strongly recommended that you use the bcrypt library to handle salting and hashing.</p>

        <br>
        <h5>Login</h5>
        <p>When a user sends a login request, authenticate the request based on the data stored in your database. If the
            [salted hash of the] password matches what you have stored in the database, the user is authenticated.</p>


        <p>When a user successfully logs in, set an authentication token named exactly "auth_token" as a cookie for that
            user with the HttpOnly
            directive set. These token cannot be session cookies (eg. set max age or expires). You must store a hash
            (no
            salt) of each token in your database so you can verify them on subsequent requests. Remember that you do not
            hash the cookie, but you do hash what's stored in the DB</p>
        <p>
            If a login is not successful (eg. username doesn't exist), return a 400 response with a message of
            your choosing.
        </p>
        <p><b>Security</b>: Only hashes of your auth tokens should be stored in your database (Do not store the tokens
            as plain
            text). Salting is not expected.</p>
        <p><b>Security</b>: Set the HttpOnly directive on your "auth_token" cookie.</p>

        <br>
        <h5>Logout</h5>
        <p>Add a path for GET "/logout", that is used by the logout button on the front end, that will log a user out.
            When this button is pressed, the user's auth token must be removed from their cookies and invalidated
            by your server (eg. the auth token they were issued should no longer work even if your server receives it as
            a
            cookie value after log out). To remove a cookie, set a cookie with the same name and max age of 0 or an
            expires
            date in the past. For the response, send a 302 Found that redirects the user to your homepage.</p>

        <br>
        <h5>Authenticated Chat</h5>
        <p>Whenever a chat message is sent by an authenticated user, the message should contain their
            actual username. This is done by setting the "author" of their messages to their username.</p>

        {#        <p>This is no longer required since it depends on an Application Objective from a previous assignment. <s>#}
        {#            When a user logs into their account, any messages that they sent as a guest should retroactively have#}
        {#            their author set to#}
        {#            their username. Use your "session" cookie to track messages for this purpose. You should also ensure that#}
        {#            messages cannot be "claimed" multiple times (eg. If a user sends a guest message, logs in, logs out, then#}
        {#            logs in using a different account, the guest message should still belong to the account of their first#}
        {#            login).</s>#}
        {#        </p>#}
        {##}
        {#        <p><s>#}
        {#            Note: To accomplish this, you will need to read the "session" cookie on login. Some browsers will#}
        {#            automatically add a "/api" path to this cookie so it will not be sent to the /login path. To correct this,#}
        {#            manually set the path directive to "/"</s>#}
        {#        </p>#}

        <br>
        <h5>Update and Delete Messages</h5>
        <p>Modify, or create if you did not finish this feature from HW1, your update and delete message functionality
            to be based on user accounts instead of "session" cookies. A user
            should be able to log out, clear all their cookies, log back in, and still be able to update/delete their
            own
            messages.</p>

        <p>When a user attempts to update or remove a message that is not their own, respond to the request with a 403
            response
            code. If it is their own, you may choose the response you send (200 with a short message is fine).</p>

        <p>
            If you did not complete the update and delete endpoints from HW1, refer to that HW doc for the
            specifications of these endpoints.
        </p>

        {#        FUTURE: add a 401 Unauthorized response if they are not logged and 403 Forbidden if they are logged in but
                  not the author. Make sure to update the grader too #}

        <br>
        <h5>@me</h5>
        <p>
            Add an endpoint GET "/api/users/@me" that will return the requesters user profile. You should return
            everything in your database stored for the user except their [hashed and salted] password and [hashed] auth
            token. This is used
            to display a users name on the page when they are logged in. If the user is not logged in, this endpoint
            returns an empty json object with a 401 status code
        </p>

        <p>Response (JSON): {"username": string "id": string}</p>

        <p>
            As more data is added to user profiles, that data should also be returned by this endpoint.
        </p>

        <br>
        <h5>Filter/search users</h5>
        <p>
            Add an endpoint GET "/api/users/search" that takes a query string containing one key named "user". Return a
            json object containing all the users with a username that starts with the query value with the following
            structure {"users": [{ "id": "1", "username": "bob" }, ...]}. This endpoint is case-sensitive,
            meaning if a username is "Username" and the search is for "use" it will not return "Username", but a search
            for "Use" will.
        </p>
        <p>
            If the search term (The value of "user" in the query string) is empty, do not return any results.
        </p>

        <br>
        <h5>Update profile</h5>
        <p>
            Add an endpoint POST "/api/users/settings" which will receive requests containing a username and password in
            the same format as the registration and login endpoints. When you receive a request at this endpoint, update
            the users username and password to the provided values.
        </p>

        <p>
            This endpoint must enforce the same password criteria as registering a new user. If the password does not
            meet all criteria, return a 400 response with a message of your choice. Do not update their username, or
            password, if the password is not valid.
        </p>

        <p>
            To avoid users having to give their password every time they want to change just their username, an empty
            password field should be interpreted as a request to change only their username. Note that this is not
            checked during grading, but can be added to improve usability of the app.
        </p>
        <p>
            You do not have to change the author of the users prior messages when they change their username. Their old
            messages can still have their old username.
            {# FUTURE: Change this so they do have to update the old messages. It's not much work and gets them using the DB a little more #}
        </p>

        <p>
            When a password is changed, they must not be able to login with their old password.
        </p>

        <br>
        <hr/>
        <h3>
            Application Objective 1 - 2-Factor Authentication
        </h3>
        <hr/>

        <div class="alert alert-info">
            Note: Starting with this objective, all Application Objectives will require that your app functions properly
            using docker compose. When running "docker compose up" your app must be fully functional on localhost port
            8080. If docker is not setup properly, you cannot earn credit for any of the Application Objectives even if
            you wrote functioning code for the objective.
        </div>

        <p>
            A quick note: Application objectives are more open-ended in how you implement them than the Learning
            Objectives (Enabled by them being manually graded).
            This will require a lot of exploration and reading online documentation.
            You should snoop around the network tab and inspect how requests are sent and what responses are expected.
            Furthermore, because of the open-ended nature of the AOs and the manual grading involved,
            your implementation can vary in terms of formatting.
            As long as you achieve the goal of the AO (and don't violate the spirit of the AO),
            and your implementation works with the frontend without any frontend modifications, you needn't worry.

            You may still lose AO credit if you utilize any unallowed libraries (ask first before you use a library that
            isn't already approved!), your server does not function properly with docker compose,
            or you otherwise violate the spirit of the AOs.
        </p>

        <p>
            Enable time-based one-time password (<a href="https://www.twilio.com/docs/glossary/totp">TOTP</a>) based
            2-factor authentication (2FA) on your app.
            This objective will require inspecting network requests and
            reviewing some frontend files (you shouldn't edit anything on the front end) to learn exactly
            how to implement this feature.
        </p>

        <p>
            When a user enables 2FA by clicking "Regenerate 2FA" on the setting page,
            your app should return a json object in the format {"secret": string}. Each time a user clicks "Regenerate
            2FA",
            your server is expected to generate a new secret. The front end will use this secret to
            generate a QR code which your users can scan using any authenticator app on their phone
            (eg. <a href="https://www.authy.com/">Authy</a>, Duo, Google Authenticator). You may choose any high-entropy
            string for your secrets. The secrets must be different for each user.
        </p>

        <p>
            When a user with 2FA enabled logs in, you should expect them to provide a TOTP code in addition to their
            username and password. If no TOTP code is provided (The request only contains username and password), return
            a 401 response with a message of your choosing. If a TOTP code is provided you will verify this code while
            authenticating them. Study the front end and network traffic to
            see the exact format of this code in the request. You may want to modify your extract_credentials function
            to also extract the TOTP if it's present (Be sure to not break logging in without TOTP when making changes).
            If both their password and TOTP code are valid, they should be logged in.
        </p>

        <p>You can, and should, use the <a href="https://pyauth.github.io/pyotp/">PYOTP library</a> to
            generate secrets and verify TOTPs.</p>

        <br>
        <hr/>
        <h3>
            Application Objective 2 - Login with GitHub (Oauth 2.0)
        </h3>
        <hr/>

        <p>
            Enable the "login with GitHub" button. This button uses the GET "/authgithub" endpoint. You should add
            functionality on this endpoint to follow the OAuth 2.0 protocol. After authenticating their account
            through GitHub, use the API to get the user's username (or email if available). Use this as their
            username for any messages they send.
        </p>

        <p>
            You will use the Authorization Code Flow to build this feature, and you should follow
            <a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app">
                the documentation</a> to guide
            your development. You will need a GitHub account to access the dev dashboard and this can be a free account.
            Once you do, follow the Authorization Code Flow documentation which GitHub calls their
            <a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow">
                Web Application Flow</a>. No, you cannot use the Device Flow or the Non-Web Application Flow.
        </p>

        <p>Use "http://localhost:8080/authcallback" as your redirect_uri. The course staff will use this exact string in
            their
            GitHub app used to test your app.
            Ensure that you are requesting the appropriate scopes in order to access the user's information.
{#            During your testing, make sure you are granting permission to the appropriate repos and orgs you are testing#}
{#            with.#}
{#            Do not spam public repos, or repos that you do not own/have affiliation with. Seriously.#}
        </p>


        <p>You may use a library (eg. requests) to send HTTP requests to the GitHub API. You are also allowed to use the
            base64 library, if needed.</p>

        <p>Note: You are not required to handle refresh tokens. You should code this for extra
            practice and experience, but it would be too tedious to test/grade such a
            requirement since we'd have to wait for the tokens to expire before refreshing them.</p>

        <p><b>Security</b>: Never share your app's client secret. Your submission must not contain your
            client secret and should instead have placeholders/variables where it should go.</p>

        <p>Instead of submitting your code with this secret and id, set these values as environment variables in a
            file named ".env". See the provided .env.example file for reference on the syntax. Use the variables names
            "GITHUB_CLIENT_ID" and "GITHUB_CLIENT_SECRET" in this file. You can then use the
            python-dotenv library to read this file on server startup. You will then have access to these variables
            anywhere in your code (See database.py for an example of reading an environment variable).
            Your submission should have placeholder values for these variables (ie. "changeMe"
            or
            "Put your client secret here" or ""). For testing, we will paste our own secret/id into your .env file
            before
            running your app. You may also set your REDIRECT_URI this way if you prefer not to hardcode it.</p>

        <p><b>Security</b>: You must properly use the Authorization Code Flow. Using a different flow, or improperly
            using the
            Authorization Code Flow, that exposes your app to security issues discussed in lecture is a security
            concern.</p>


        {#        <br>#}
        {#        <hr/>#}
        {#        <h3>#}
        {#            Application Objective 3 - GitHub Chat Commands#}
        {#        </h3>#}
        {#        <hr/>#}
        {##}
        {#        <p>#}
        {#            If a user is logged in using GitHub, as opposed to using the register/login flow from the learning#}
        {#            objective,#}
        {#            they can enter special commands into the chat. If they type any of these commands into chat, your app will#}
        {#            use the GitHub API to generate the text of their message. All commands begin with the character '/'. If any#}
        {#            message is sent to chat that starts with /, you should treat it as a chat command and replace whatever was#}
        {#            sent with the result of the chat command. If a user is not logged in as an oauth user, you should reject the request#}
        {#            with a 400. If the inputs given by the user (repo name, etc) are not correct in any way (no access, doesn't exist, etc)  #}
        {#            you should reject with a 400 and a message describing why. #}
        {#            #}
        {#            The commands are:#}
        {#        </p>#}
        {##}
        {#        <ul>#}
        {#            <li>#}
        {#                /repos @user#}
        {#                <ul>#}
        {#                    <li>List all GitHub repos of the target user (limit 50). These repos should appear as links where#}
        {#                        the text is the repo name. You have some flexibility in how to display all the links#}
        {#                    </li>#}
        {#                    <li>Example: A message of "/repos ufoscout" will generate a message with 50 links to user ufoscouts#}
        {#                        GitHub repos#}
        {#                    </li>#}
        {#                    <li>Note: This command may result in HTML being rendered in chat. Since this HTML is completely under#}
        {#                        the control of your server, it is ok to render on the front end. #}
        {#                    </li>#}
        {#                </ul>#}
        {#            </li>#}
        {#            <li>/star @repo#}
        {#                <ul>#}
        {#                    <li>use the current oauth user to star the provided repo. Display a confirmation of the star in#}
        {#                        chat#}
        {#                    </li>#}
        {#                    <li>#}
        {#                        Example: A message of "/star ufoscout/docker-compose-wait" from a user who logged in with GitHub#}
        {#                        will result in that user starring the repo ufoscout/docker-compose-wait and a chat message being#}
        {#                        displayed confirming that it was starred. This can be a message of your choosing, but we ask that#}
        {#                        you make life easier for the graders and wrap the content in a link to the repo for easy viewing.#}
        {#                    </li>#}
        {#                </ul>#}
        {#            </li>#}
        {##}
        {#            <li>/createissue @repo @title#}
        {#                <ul>#}
        {#                    <li>Creates an issue on @repo with a title of @title. The body of this issue should be empty (Unless#}
        {#                        you want to add this functionality, but it's not required). Display a confirmation of the#}
        {#                        created issue in chat#}
        {#                    </li>#}
        {#                    <li>#}
        {#                        Example: A message of "/createissue CSE-312/CSE312-Website Finish the HW2 handout doc" will#}
        {#                        create an issue on the CSE-312/CSE312-Website repo with the title "Finish the HW2 handout doc"#}
        {#                        and an empty body and a confirmation message will be displayed in chat. #}
        {#                        This can be a message of your choosing, but we ask that#}
        {#                        you make life easier for the graders and wrap the content in a link to the created issue for easy viewing.#}
        {#                    </li>#}
        {#                </ul>#}
        {#            </li>#}
        {#        </ul>#}


        <br>
        <hr>
        <h3>Submission</h3>
        <hr>
        <p>Submit all files for your server to Autolab in a .zip file</p>

        <p>
            If you used any external libraries, be sure to add them to your requirements.txt. Autolab will install all
            dependencies in this file, and no other dependencies, before starting your server.
        </p>

        <div class="alert alert-info">
            It is strongly recommended that you download and test your submission after submitting. To do this, download
            your zip file into a new directory, unzip your zip file, enter the directory where the files were unzipped,
            run
            docker compose up, then navigate to localhost:8080 in your browser and test all of your features. This
            simulates exactly what the TAs will do during grading.
            <br><br>
            If you ignore this recommendation, don't be surprised when you do not earn credit for either Application
            Objective even if your code functions properly when running server.py
        </div>

        <br>
        <hr>
        <h3>Grading</h3>
        <hr>
        <p>Each objective will be scored on a 0-3 scale as follows:</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3 (Complete)</td>
                <td>Clearly correct</td>
            </tr>
            <tr>
                <td>2 (Complete)</td>
                <td>Mostly correct, but with some minor issues
                </td>
            <tr>
                <td>1 (Incomplete)</td>
                <td>Not all features outlined in this document are functional, but an honest attempt was made to
                    complete the objective
                </td>
            <tr>
                <td>0.3 (Incomplete)</td>
                <td>The objective would earn a 3, but a security risk was found while testing</td>
            <tr>
                <td>0.2 (Incomplete)</td>
                <td>The objective would earn a 2, but a security risk was found while testing</td>
            <tr>
                <td>0.1 (Incomplete)</td>
                <td>The objective would earn a 1, but a security risk was found while testing</td>
            <tr>
                <td>0 (Incomplete)</td>
                <td>No attempt to complete the objective or violation of the assignment (Ex. Using an HTTP library)</td>
        </table>
        <br>
        <p>Note that for your final grade there is no difference between a 2 and 3, or a 0 and a 1. The numeric score
            is meant to give you more feedback on your work.</p>

        <table class="table table-bordered table-skinny">
            <tr>
                <td>3</td>
                <td>Objective Complete</td>
            </tr>
            <tr>
                <td>2</td>
                <td>
                    Objective Complete
                </td>
            </tr>
            <tr>
                <td>1</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
            <tr>
                <td>0</td>
                <td>
                    Objective Not Complete
                </td>
            </tr>
        </table>
        <br>
        <p>Autograded objectives are graded on a pass/fail basis with grades of 3.0 or 0.0.</p>

        <br>
        <hr>
        <h3>Security Essay</h3>
        <br>
        <p>For each objective for which you earned a 0.3 or 0.2, you will still have an opportunity to earn credit for
            the
            objective by submitting an essay about the security issue you exposed. These essays must:</p>

        <ul>
            <li>Be at least 1000 words in length</li>
            <li>Explain the security issue from your submission with specific details about your code</li>
            <li>Describe how you fixed the issue in your submission with specific details about the code you changed
            </li>
            <li>Explain why this security issue is a concern and the damage that could be done if you exposed this issue
                in
                production code with live users
            </li>
        </ul>


        <p>Any submission that does not meet all these criteria will be rejected and your objective will remain
            incomplete.</p>

        <p>Due Date: Security essays are due 1-week after grades are released.</p>

        <p>Any essay may be subject to an interview with the course staff to verify that you understand the importance
            of
            the security issue that you exposed. If an interview is required, you will be contacted by the course staff
            for
            scheduling. Decisions of whether or not an interview is required will be made at the discretion of the
            course
            staff.</p>

        <p>When you don't have to write an essay:</p>
        <ul>
            <li>If you never submit a security violation, you never have to write an essay for this course. Be safe. Be
                secure
            </li>
            <li>If you earn a 0.1, there's no need to write an essay since you would not complete the objective anyway
            </li>
        </ul>


    </div>
{% endblock %}
